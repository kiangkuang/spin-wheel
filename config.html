<!DOCTYPE html>
<html lang="en" data-bs-theme="dark">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Wheel Configuration</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
      .drag-handle {
        cursor: grab;
        color: var(--bs-secondary-color);
      }

      .dragging .drag-handle {
        cursor: grabbing;
      }

      .dragging {
        opacity: 0.95;
        background-color: var(--bs-secondary-bg);
        box-shadow: rgba(0, 0, 0, 0.2) 0px 5px 15px;
        transform: translate(8px, -4px);
        transition: box-shadow 0.2s, transform 0.2s, background-color 0.2s;
      }

      .row {
        cursor: default;
        transition: box-shadow 0.2s, transform 0.2s, background-color 0.2s;
      }
    </style>
  </head>

  <body>
    <div id="app" class="container py-4">
      <h1>Wheel Configuration</h1>

      <div class="mb-4">
        <div
          v-for="(item, index) in items"
          :key="index"
          class="row g-2 pb-2 my-1 align-items-center rounded"
          :class="{ dragging: draggingIndex === index }"
        >
          <div class="col-1">
            <div
              class="drag-handle"
              draggable="true"
              @dragstart="dragStart($event, index)"
              @dragover.prevent
              @dragenter.prevent="dragEnter($event, index)"
              @dragend="dragEnd"
              @touchstart="touchStart($event, index)"
              @touchmove.prevent="touchMove($event)"
              @touchend="touchEnd"
            >
              ⋮⋮
            </div>
          </div>
          <div class="col-11 col-md">
            <input
              v-model.trim="item.label"
              class="form-control"
              placeholder="Label"
            />
          </div>
          <div class="col offset-1 col-md-2 offset-md-0">
            <input
              v-model.trim="item.backgroundColor"
              class="form-control"
              placeholder="Color"
              list="colorOptions"
              :style="{ backgroundColor: item.backgroundColor, color: getContrastColor(item.backgroundColor) }"
            />
            <datalist id="colorOptions">
              <option value="red"></option>
              <option value="blue"></option>
              <option value="green"></option>
              <option value="yellow"></option>
              <option value="orange"></option>
              <option value="purple"></option>
              <option value="pink"></option>
              <option value="navy"></option>
              <option value="teal"></option>
              <option value="brown"></option>
            </datalist>
          </div>
          <div class="col-2">
            <input
              v-model.number="item.weight"
              type="number"
              class="form-control"
              min="1"
              placeholder="Weight"
            />
          </div>
          <div class="col-auto">
            <button @click="removeItem(index)" class="btn btn-danger w-100">
              ×
            </button>
          </div>
        </div>

        <button @click="addItem" class="btn btn-primary">Add Item</button>
      </div>

      <div>
        <p class="text-muted mb-2">Recommended steps:</p>
        <ol class="text-muted small mb-3">
          <li>Open the wheel to verify your configuration</li>
          <li>Copy the URL</li>
          <li>Create a shorter link using TinyURL</li>
        </ol>

        <div class="d-flex gap-2">
          <a :href="wheelUrl" class="btn btn-secondary">1. Open Wheel</a>
          <button @click="copyUrl" class="btn btn-primary">
            2. {{copyBtnText}}
          </button>
          <a href="https://tinyurl.com" target="_blank" class="btn btn-success">
            3. Shorten URL
          </a>
        </div>
      </div>
    </div>

    <script>
      const { createApp, ref, computed, watchEffect } = Vue;

      const useDraggableList = (items) => {
        const dragState = ref({
          index: null,
          touchY: null,
        });

        const reorderItems = (fromIndex, toIndex) => {
          if (fromIndex === toIndex) return;
          const [item] = items.value.splice(fromIndex, 1);
          items.value.splice(toIndex, 0, item);
          dragState.value.index = toIndex;
        };

        const findDropIndex = (clientY) => {
          const elements = document.querySelectorAll(".row");
          return Array.from(elements).findIndex((el, index) => {
            if (index === dragState.value.index) return false;
            const rect = el.getBoundingClientRect();
            if (clientY < rect.top || clientY > rect.bottom) return false;

            const movingDown = dragState.value.touchY < clientY;
            const targetMiddle = rect.top + rect.height / 2;
            return (
              (movingDown && clientY > targetMiddle) ||
              (!movingDown && clientY < targetMiddle)
            );
          });
        };

        const dragHandlers = {
          dragStart: (e, index) => {
            dragState.value.index = index;
            e.dataTransfer.effectAllowed = "move";
          },
          dragEnter: (e, index) => reorderItems(dragState.value.index, index),
          dragEnd: () => (dragState.value = { index: null, touchY: null }),
          touchStart: (e, index) => {
            dragState.value = {
              index: index,
              touchY: e.touches[0].clientY,
            };
          },
          touchMove: (e) => {
            if (dragState.value.index === null) return;
            const currentY = e.touches[0].clientY;
            const newIndex = findDropIndex(currentY);

            if (newIndex !== -1) {
              reorderItems(dragState.value.index, newIndex);
            }
            dragState.value.touchY = currentY;
          },
          touchEnd: () => (dragState.value = { index: null, touchY: null }),
        };

        return {
          draggingIndex: computed(() => dragState.value.index),
          ...dragHandlers,
        };
      };

      createApp({
        setup() {
          const parseItemsFromUrl = () => {
            try {
              return JSON.parse(
                new URLSearchParams(window.location.search).get("items"),
              );
            } catch (e) {
              return null;
            }
          };

          const defaultItems = [
            { label: "Item 1", backgroundColor: "orange", weight: 2 },
            { label: "Item 2", backgroundColor: "navy", weight: 3 },
            { label: "Item 3", backgroundColor: "red", weight: 4 },
          ];

          const parsedItems = parseItemsFromUrl();
          const items = ref(
            !parsedItems || parsedItems.length === 0
              ? defaultItems
              : parsedItems,
          );

          const copyBtnText = ref("Copy URL");

          const {
            draggingIndex,
            dragStart,
            dragEnter,
            dragEnd,
            touchStart,
            touchMove,
            touchEnd,
          } = useDraggableList(items);

          const addItem = () => {
            items.value.push({
              label: `Item ${items.value.length + 1}`,
              backgroundColor:
                items.value.length >= 2
                  ? items.value[items.value.length - 2].backgroundColor
                  : "orange",
              weight: 1,
            });
          };

          const removeItem = (index) => {
            items.value.splice(index, 1);
          };

          const wheelUrl = computed(() => {
            const params = new URLSearchParams();
            params.set("items", JSON.stringify(items.value));
            return `index.html?${params.toString()}`;
          });

          const getContrastColor = (bgColor = "") => {
            // For common dark colors, return white
            const darkColors = [
              "navy",
              "blue",
              "purple",
              "red",
              "green",
              "brown",
              "black",
            ];
            if (darkColors.includes(bgColor.toLowerCase())) return "white";
            return "black";
          };

          const copyUrl = () => {
            navigator.clipboard.writeText(wheelUrl.value).then(() => {
              copyBtnText.value = "Copied!";
              setTimeout(() => {
                copyBtnText.value = "Copy URL";
              }, 2000);
            });
          };

          // Update URL when items change
          watchEffect(
            () => {
              const params = new URLSearchParams(window.location.search);
              params.set("items", JSON.stringify(items.value));
              const newUrl = `${window.location.pathname}?${params.toString()}`;
              history.replaceState(null, "", newUrl);
            },
            { deep: true },
          );

          return {
            items,
            addItem,
            removeItem,
            wheelUrl,
            getContrastColor,
            copyUrl,
            copyBtnText,
            draggingIndex,
            dragStart,
            dragEnter,
            dragEnd,
            touchStart,
            touchMove,
            touchEnd,
          };
        },
      }).mount("#app");
    </script>
  </body>
</html>
